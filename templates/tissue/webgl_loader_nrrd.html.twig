<!DOCTYPE html>
<html lang="en">

<head>
	<title>Tissue Reader</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="./threejs/examples/main.css">
	<style>
		#inset {
			width: 150px;
			height: 150px;
			background-color: transparent;
			/* or transparent; will show through only if renderer alpha: true */
			border: none;
			/* or none; */
			margin: 0;
			padding: 0px;
			position: absolute;
			left: 20px;
			bottom: 20px;
			z-index: 100;
		}
	</style>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
</head>

<body>
	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> -
		NRRD model
	</div>
	<div id="inset"></div>
	<div id='tooltip' style='visibility: hidden; position: absolute; color: white; font-family:sans-serif'> </div>
	<script type="module">

		import * as THREE from './threejs/build/three.module.js';

		import Stats from './threejs/examples/jsm/libs/stats.module.js';

		import { GUI } from './threejs/examples/jsm/libs/dat.gui.module.js';
		import { TrackballControls } from './threejs/examples/jsm/controls/TrackballControls.js';
		import { NRRDLoader } from './threejs/examples/jsm/loaders/NRRDLoader.js';
		//import { VTKLoader } from './jsm/loaders/VTKLoader.js';

		let container,
			stats,
			camera,
			controls,
			scene,
			renderer,
			container2,
			renderer2,
			camera2,
			axes2,
			scene2;

		const raycaster = new THREE.Raycaster();
		const mouse = new THREE.Vector2();
		const gui = new GUI();
		var currentIndexZ = 0;
		var tissueDim = null;
		var cells = [];

		init();
		animate();

		function loadTissue(tissueType){
			$.ajax({
                    //url: `/tissue/get/${tissueType}`,
					url: `/tissue/get/all`,
                    type: "GET",
                    //data: JSON.stringify(data),
                    processData: false,
                    contentType: false,
                    cache: false,
                    success: ((response)=>{
						cells = response;
						// drawing centroid of all tissues
						for (var i = 0; i < cells.length; i++){
							var geometryCell = new THREE.SphereGeometry( 3, 32, 32 );
							var materialCell = new THREE.MeshPhongMaterial({
												color: 0x00ff00,
												opacity: 0.5,
												transparent: true,}
												);
							var cell = new THREE.Mesh( geometryCell, materialCell );
							// move cell according to new root
							cells[i].centroidX = cells[i].centroidX - Math.floor(tissueDim.xL / 2);
							cells[i].centroidY = cells[i].centroidY - Math.floor(tissueDim.yL / 2);
							cells[i].centroidZ = cells[i].centroidZ - Math.floor(tissueDim.zL / 2);

							cell.position.x = cells[i].centroidX;
							cell.position.y = cells[i].centroidY;
							cell.position.z = cells[i].centroidZ;
							cell.name = cells[i].id;
							cell.userData = cell[i];
							scene.add(cell);
						}
                    }),
                    error:function(response){
                        console.log(response); 
                    }
                });
		};

		function init() {

			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 1e10);
			camera.position.z = 500;

			scene = new THREE.Scene();

			scene.add(camera);

			// light

			const hemiLight = new THREE.HemisphereLight(0xffffff, 0x000000, 1);
			scene.add(hemiLight);

			const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
			dirLight.position.set(200, 200, 200);
			scene.add(dirLight);

			const loader = new NRRDLoader();
			loader.load("threejs/examples/models/nrrd/Well001_LECTINE.nrrd", function (volume) {
				//loader.load( "models/nrrd/I.nrrd", function ( volume ) {
				//box helper to see the extend of the volume
				tissueDim = {xL: volume.xLength, yL: volume.yLength, zL: volume.zLength};
				const geometry = new THREE.BoxGeometry(volume.xLength, volume.yLength, volume.zLength);
				const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
				const cube = new THREE.Mesh(geometry, material);
				cube.visible = false;
				const box = new THREE.BoxHelper(cube);
				box.name = 'tissue';
				scene.add(box);
				box.applyMatrix4(volume.matrix);
				scene.add(cube);

				loadTissue("lectine");

				//z plane
				const sliceZ = volume.extractSlice('z', Math.floor(volume.RASDimensions[2] / 4));
				scene.add(sliceZ.mesh);
				currentIndexZ = Math.floor(volume.RASDimensions[2] / 4);

				//y plane
				const sliceY = volume.extractSlice('y', Math.floor(volume.RASDimensions[1] / 2));
				scene.add(sliceY.mesh);

				//x plane
				const sliceX = volume.extractSlice('x', Math.floor(volume.RASDimensions[0] / 2));
				scene.add(sliceX.mesh);

				gui.add(sliceX, "index", 0, volume.RASDimensions[0], 1).name("indexX").onChange(function () {

					sliceX.repaint.call(sliceX);

				});
				gui.add(sliceY, "index", 0, volume.RASDimensions[1], 1).name("indexY").onChange(function () {

					sliceY.repaint.call(sliceY);

				});
				gui.add(sliceZ, "index", 0, volume.RASDimensions[2], 1).name("indexZ").onChange(function (value) {
					currentIndexZ = value;
					sliceZ.repaint.call(sliceZ);
				});

				gui.add(volume, "lowerThreshold", volume.min, volume.max, 1).name("Lower Threshold").onChange(function () {

					volume.repaintAllSlices();

				});
				gui.add(volume, "upperThreshold", volume.min, volume.max, 1).name("Upper Threshold").onChange(function () {

					volume.repaintAllSlices();

				});
				gui.add(volume, "windowLow", volume.min, volume.max, 1).name("Window Low").onChange(function () {

					volume.repaintAllSlices();

				});
				gui.add(volume, "windowHigh", volume.min, volume.max, 1).name("Window High").onChange(function () {

					volume.repaintAllSlices();

				});
			});

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);

			container = document.createElement('div');
			document.body.appendChild(container);
			container.appendChild(renderer.domElement);

			controls = new TrackballControls(camera, renderer.domElement);
			controls.minDistance = 100;
			controls.maxDistance = 500;
			controls.rotateSpeed = 5.0;
			controls.zoomSpeed = 5;
			controls.panSpeed = 2;

			stats = new Stats();
			container.appendChild(stats.dom);

			//const gui = new GUI();

			setupInset();

			window.addEventListener('resize', onWindowResize);
			renderer.domElement.addEventListener('click', onClick, false);

		}

		function onClick() {

			event.preventDefault();
			// remove previous plane
			var previousPlane = scene.getObjectByName("plane");
			if (previousPlane != null){
				scene.remove(previousPlane);
			}
			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

			raycaster.setFromCamera(mouse, camera);

			var intersects = raycaster.intersectObjects(scene.children, true);

			if (intersects.length > 0) {
				
				// calculate real coordinates in the object
				//var tissue = scene.getObjectByName("tissue");
				var relativeCentroid = {x: 0, y: 0, z: 0};
				var realCentroid = {x: 0, y: 0, z: 0};
				relativeCentroid.x = Math.floor(tissueDim.xL / 2) + Math.floor(intersects[0].point.x);
				relativeCentroid.y = Math.floor(tissueDim.yL / 2) + Math.floor(intersects[0].point.y);
				relativeCentroid.z = currentIndexZ - Math.floor(tissueDim.zL / 2);
				realCentroid = Object.assign({}, relativeCentroid);
				realCentroid.z = currentIndexZ;
				var planeSize = 100;
				var data = {
					centroid: realCentroid,
					size: planeSize
				};
				// console.log(centroid);
				/*
				$.ajax({
                    url: "/tissue/get/statistics",
                    type: "POST",
                    data: JSON.stringify(data),
                    processData: false,
                    contentType: false,
                    cache: false,
                    success: ((response)=>{
                        console.log(response);
                    }),
                    error:function(response){
                        console.log(response); 
                    }
                });
				*/

				// create a square at this position
				/*
				var geometryPlane = new THREE.PlaneGeometry(planeSize, planeSize);
				var materialPlane = new THREE.MeshBasicMaterial({ color: 0x48C9B0, side: THREE.DoubleSide });
				var plane = new THREE.Mesh(geometryPlane, materialPlane);
				*/
				var geometryPlane = new THREE.BoxBufferGeometry( planeSize, planeSize, planeSize); 
				var materialPlane = new THREE.MeshBasicMaterial( { color: 0x48C9B0, wireframe: true } ); 
				var plane = new THREE.Mesh( geometryPlane, materialPlane );
				
				plane.position.x = intersects[0].point.x;
				plane.position.y = intersects[0].point.y;
				plane.position.z = realCentroid.z;
				plane.name = 'plane';
				scene.add(plane);

				// search objects inside this plane
				var xLow = plane.position.x - Math.floor(planeSize / 2);
				var yLow = plane.position.y - Math.floor(planeSize / 2);
				var zLow = plane.position.z - Math.floor(planeSize / 2);
				var xHigh = plane.position.x + Math.floor(planeSize / 2);
				var yHigh = plane.position.y + Math.floor(planeSize / 2);
				var zHigh = plane.position.z + Math.floor(planeSize / 2);

				var density = 0;
				var avgVolume = 0;
				var avgCompactness = 0;
				var avgElongation = 0;
				for (var i = 0; i < cells.length; i++){
					if (cells[i].centroidX >= xLow && cells[i].centroidX <= xHigh &&
						cells[i].centroidY >= yLow && cells[i].centroidY <= yHigh &&
						cells[i].centroidZ >= zLow && cells[i].centroidZ <= zHigh
						){
							density ++;
							avgVolume += cells[i].volume;
							avgCompactness += cells[i].compactness;
							avgElongation += cells[i].elongation;
							//console.log(cells[i]);
							var selectedCell = scene.getObjectByName(cells[i].id);
							//console.log(selectedCell);
							// save its color
							//var pickedObjectSavedColor = selectedCell.material.emissive.getHex();
							// set its emissive color to flashing red/yellow
							//selectedCell.material.color.setHex(0xFF0000);
						}
				}
				
				// display selected coordinates
				var coordinates = '(x: ' + realCentroid.x + ',' +
									' y: ' + realCentroid.y + ',' +
									' z: ' + realCentroid.z + ')';
				var info = `Density: ${density} <br> 
							Avg Volume: ${avgVolume} <br>
							Avg Compactness: ${avgCompactness} <br>
							Avg Elongation: ${avgElongation}`
							;					
				tooltip.innerHTML = info;
				tooltip.style.visibility = 'visible';
				tooltip.style.top = event.clientY + 'px';
				tooltip.style.left = event.clientX + 20 + 'px';
			}

		}

		function onMouseMove(event) {

			// calculate mouse position in normalized device coordinates
			// (-1 to +1) for both components

			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

			controls.handleResize();

		}

		function animate() {

			requestAnimationFrame(animate);

			controls.update();

			//copy position of the camera into inset
			camera2.position.copy(camera.position);
			camera2.position.sub(controls.target);
			camera2.position.setLength(300);
			camera2.lookAt(scene2.position);

			renderer.render(scene, camera);
			renderer2.render(scene2, camera2);

			stats.update();

		}

		function setupInset() {

			const insetWidth = 150, insetHeight = 150;
			container2 = document.getElementById('inset');
			container2.width = insetWidth;
			container2.height = insetHeight;

			// renderer
			renderer2 = new THREE.WebGLRenderer({ alpha: true });
			renderer2.setClearColor(0x000000, 0);
			renderer2.setSize(insetWidth, insetHeight);
			container2.appendChild(renderer2.domElement);

			// scene
			scene2 = new THREE.Scene();

			// camera
			camera2 = new THREE.PerspectiveCamera(50, insetWidth / insetHeight, 1, 1000);
			camera2.up = camera.up; // important!

			// axes
			axes2 = new THREE.AxesHelper(100);
			scene2.add(axes2);

		}

	</script>

</body>

</html>